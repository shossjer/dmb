
#include <x86intrin.h>

using usize = decltype(sizeof 0);
using utime = usize;

__attribute__((noinline)) static utime measure_tsc_overhead(usize cnt)
{
	utime min_measurement = utime(-1);

	do
	{
		unsigned bfrlo, bfrhi, afrlo, afrhi;

		_mm_mfence();
		asm volatile(
			"xor %%eax, %%eax\n\t"
			"xor %k2, %%ecx\n\t"  // %k2 - the low 32 bits of %2
			"cpuid\n\t"
			"rdtsc\n\t"
			"lfence\n\t"
			"mov %%edx, %0\n\t"
			"mov %%eax, %1"
			: "=r" (bfrhi), "=r" (bfrlo), "+r" (cnt)
			:
			: "%rax", "%rdx", "%rbx", "%rcx"
		);

		// benchmark goes here

		asm volatile(
			"xor %%eax, %%eax\n\t"
			"xor %k2, %%ecx\n\t"
			"cpuid\n\t"
			"rdtsc\n\t"
			"lfence\n\t"
			"mov %%edx, %0\n\t"
			"mov %%eax, %1"
			: "=r" (afrhi), "=r" (afrlo), "+r" (cnt)
			:
			: "%rax", "%rdx", "%rbx", "%rcx"
		);
		_mm_mfence();

		const utime measurement = (((utime)afrhi << 32) | afrlo) - (((utime)bfrhi << 32) | bfrlo);
		if (measurement < min_measurement)
			min_measurement = measurement;

		cnt--;
	}
	while (cnt > 0);

	return min_measurement;
}

#include <cstdio>

int main(int argc, const char * argv[])
{
	usize cnt = 100000000; // arbitrary
	if (argc > 1)
	{
		::sscanf(argv[1], "%zu", &cnt);
	}

	utime tsc_overhead = measure_tsc_overhead(cnt);

	FILE * const overhead_file = ::fopen("overhead.hpp", "wb");
	if (overhead_file != nullptr)
	{
		::fprintf(overhead_file, "// generated by dmbgen\n\nnamespace dmb\n{\n\tstatic constexpr const utime tsc_overhead = %zu;\n}\n", tsc_overhead);
		::fclose(overhead_file);
	}

	return 0;
}
